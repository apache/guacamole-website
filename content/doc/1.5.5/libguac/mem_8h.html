<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libguac: guacamole/mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libguac<span id="projectnumber">&#160;1.5.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6bb9fad85c98b48a11165f494b9f53ce.html">guacamole</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">mem.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides convenience macros/functions for performing arithmetic on size_t values and for allocating memory, particularly memory related to images, audio, etc.  
<a href="#details">More...</a></p>

<p><a href="mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4bb1a3a4a576b07b46b7326435e19cc5" id="r_a4bb1a3a4a576b07b46b7326435e19cc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5">guac_mem_alloc</a>(...)</td></tr>
<tr class="memdesc:a4bb1a3a4a576b07b46b7326435e19cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte of that block of memory.  <br /></td></tr>
<tr class="separator:a4bb1a3a4a576b07b46b7326435e19cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03391fbf6e9bababa2acc8d2094f42d2" id="r_a03391fbf6e9bababa2acc8d2094f42d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2">guac_mem_zalloc</a>(...)</td></tr>
<tr class="memdesc:a03391fbf6e9bababa2acc8d2094f42d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero, returning a pointer to the first byte of that block of memory.  <br /></td></tr>
<tr class="separator:a03391fbf6e9bababa2acc8d2094f42d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47dabfecd807b320fa8ca35b836c3ed" id="r_ae47dabfecd807b320fa8ca35b836c3ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae47dabfecd807b320fa8ca35b836c3ed">guac_mem_ckd_mul</a>(result, ...)</td></tr>
<tr class="memdesc:ae47dabfecd807b320fa8ca35b836c3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies together each of the given values, storing the result in a size_t variable via the provided pointer.  <br /></td></tr>
<tr class="separator:ae47dabfecd807b320fa8ca35b836c3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d61800f2ad718485fbfa959784f172" id="r_a80d61800f2ad718485fbfa959784f172"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80d61800f2ad718485fbfa959784f172">guac_mem_ckd_add</a>(result, ...)</td></tr>
<tr class="memdesc:a80d61800f2ad718485fbfa959784f172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds together each of the given values, storing the result in a size_t variable via the provided pointer.  <br /></td></tr>
<tr class="separator:a80d61800f2ad718485fbfa959784f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f393eafbe5d770cddac0821b69a74c" id="r_aa7f393eafbe5d770cddac0821b69a74c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7f393eafbe5d770cddac0821b69a74c">guac_mem_ckd_sub</a>(result, ...)</td></tr>
<tr class="memdesc:aa7f393eafbe5d770cddac0821b69a74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each of the given values from each other, storing the result in a size_t variable via the provided pointer.  <br /></td></tr>
<tr class="separator:aa7f393eafbe5d770cddac0821b69a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea1730f0b59705fcd6e8ce58fa6e244" id="r_a2ea1730f0b59705fcd6e8ce58fa6e244"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ea1730f0b59705fcd6e8ce58fa6e244">guac_mem_ckd_mul_or_die</a>(...)</td></tr>
<tr class="memdesc:a2ea1730f0b59705fcd6e8ce58fa6e244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies together each of the given values, returning the result directly.  <br /></td></tr>
<tr class="separator:a2ea1730f0b59705fcd6e8ce58fa6e244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57af96611f73a3f2300ba9fd64b0167a" id="r_a57af96611f73a3f2300ba9fd64b0167a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57af96611f73a3f2300ba9fd64b0167a">guac_mem_ckd_add_or_die</a>(...)</td></tr>
<tr class="memdesc:a57af96611f73a3f2300ba9fd64b0167a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds together each of the given values, returning the result directly.  <br /></td></tr>
<tr class="separator:a57af96611f73a3f2300ba9fd64b0167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd36b5c5601983cf87a67a4e0b7fc9" id="r_acfbd36b5c5601983cf87a67a4e0b7fc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfbd36b5c5601983cf87a67a4e0b7fc9">guac_mem_ckd_sub_or_die</a>(...)</td></tr>
<tr class="memdesc:acfbd36b5c5601983cf87a67a4e0b7fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each of the given values from each other, returning the result directly.  <br /></td></tr>
<tr class="separator:acfbd36b5c5601983cf87a67a4e0b7fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57937a45796bf46eb8d3945f8eecc201" id="r_a57937a45796bf46eb8d3945f8eecc201"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57937a45796bf46eb8d3945f8eecc201">guac_mem_realloc</a>(mem, ...)</td></tr>
<tr class="memdesc:a57937a45796bf46eb8d3945f8eecc201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a contiguous block of memory that was previously allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants, returning a pointer to the first byte of that reallocated block of memory.  <br /></td></tr>
<tr class="separator:a57937a45796bf46eb8d3945f8eecc201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf838d4e8ca2397170fa71a675192ba" id="r_a1bf838d4e8ca2397170fa71a675192ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf838d4e8ca2397170fa71a675192ba">guac_mem_realloc_or_die</a>(mem, ...)</td></tr>
<tr class="memdesc:a1bf838d4e8ca2397170fa71a675192ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates a contiguous block of memory that was previously allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants, returning a pointer to the first byte of that reallocated block of memory.  <br /></td></tr>
<tr class="separator:a1bf838d4e8ca2397170fa71a675192ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca926fbc99ae497f093235f787b5b328" id="r_aca926fbc99ae497f093235f787b5b328"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca926fbc99ae497f093235f787b5b328">guac_mem_free</a>(mem)&#160;&#160;&#160;(PRIV_guac_mem_free(mem), (mem) = NULL, (void) 0)</td></tr>
<tr class="memdesc:aca926fbc99ae497f093235f787b5b328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory block at the given pointer, which MUST have been allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants.  <br /></td></tr>
<tr class="separator:aca926fbc99ae497f093235f787b5b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af8ba72e97f84fbd7600be04cc6bf39" id="r_a3af8ba72e97f84fbd7600be04cc6bf39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3af8ba72e97f84fbd7600be04cc6bf39">guac_mem_free_const</a>(mem)&#160;&#160;&#160;PRIV_guac_mem_free((void*) (mem))</td></tr>
<tr class="memdesc:a3af8ba72e97f84fbd7600be04cc6bf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory block at the given const pointer, which MUST have been allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants.  <br /></td></tr>
<tr class="separator:a3af8ba72e97f84fbd7600be04cc6bf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides convenience macros/functions for performing arithmetic on size_t values and for allocating memory, particularly memory related to images, audio, etc. </p>
<p>where there are multiple factors affecting the final size. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4bb1a3a4a576b07b46b7326435e19cc5" name="a4bb1a3a4a576b07b46b7326435e19cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb1a3a4a576b07b46b7326435e19cc5">&#9670;&#160;</a></span>guac_mem_alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_alloc</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_alloc(                                                      \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte of that block of memory. </p>
<p>If multiple sizes are provided, these sizes are multiplied together to produce the final size of the new block. If memory of the specified size cannot be allocated, or if multiplying the sizes would result in integer overflow, guac_error is set appropriately and NULL is returned.</p>
<p>This macro is analogous to the standard malloc(), but accepts a list of size factors instead of a single integer size.</p>
<p>The pointer returned by <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a> SHOULD be freed with a subsequent call to <a class="el" href="#aca926fbc99ae497f093235f787b5b328" title="Frees the memory block at the given pointer, which MUST have been allocated with guac_mem_alloc(),...">guac_mem_free()</a>, but MAY instead be freed with a subsequent call to free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A series of one or more size_t values that should be multiplied together to produce the desired block size. At least one value MUST be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first byte of the allocated block of memory, or NULL if such a block could not be allocated. If a block of memory could not be allocated, guac_error is set appropriately. </dd></dl>

</div>
</div>
<a id="a80d61800f2ad718485fbfa959784f172" name="a80d61800f2ad718485fbfa959784f172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d61800f2ad718485fbfa959784f172">&#9670;&#160;</a></span>guac_mem_ckd_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_add</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">result, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_add(                                                    \</div>
<div class="line">        result,                                                               \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Adds together each of the given values, storing the result in a size_t variable via the provided pointer. </p>
<p>If the result of the addition overflows the limits of a size_t, non-zero is returned to signal failure.</p>
<p>If the addition operation fails, the nature of any result stored in the provided pointer is undefined, as is whether a result is stored at all.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result;</div>
<div class="line"><span class="keywordtype">int</span> failed = <a class="code hl_define" href="#a80d61800f2ad718485fbfa959784f172">guac_mem_ckd_add</a>(&amp;some_result, a, b, c);</div>
<div class="ttc" id="amem_8h_html_a80d61800f2ad718485fbfa959784f172"><div class="ttname"><a href="#a80d61800f2ad718485fbfa959784f172">guac_mem_ckd_add</a></div><div class="ttdeci">#define guac_mem_ckd_add(result,...)</div><div class="ttdoc">Adds together each of the given values, storing the result in a size_t variable via the provided poin...</div><div class="ttdef"><b>Definition</b> mem.h:164</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a + b + c;</div>
</div><!-- fragment --><p>except that it is possible for interested callers to handle overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A pointer to the size_t variable that should receive the result of adding the given values.</td></tr>
    <tr><td class="paramname">...</td><td>The size_t values that should be added together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the addition was successful and did not overflow the limits of a size_t, non-zero otherwise. </dd></dl>

</div>
</div>
<a id="a57af96611f73a3f2300ba9fd64b0167a" name="a57af96611f73a3f2300ba9fd64b0167a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57af96611f73a3f2300ba9fd64b0167a">&#9670;&#160;</a></span>guac_mem_ckd_add_or_die</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_add_or_die</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_add_or_die(                                             \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Adds together each of the given values, returning the result directly. </p>
<p>If the result of the addition overflows the limits of a size_t, execution of the current process is aborted entirely, and this function does not return.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = <a class="code hl_define" href="#a57af96611f73a3f2300ba9fd64b0167a">guac_mem_ckd_add_or_die</a>(a, b, c);</div>
<div class="ttc" id="amem_8h_html_a57af96611f73a3f2300ba9fd64b0167a"><div class="ttname"><a href="#a57af96611f73a3f2300ba9fd64b0167a">guac_mem_ckd_add_or_die</a></div><div class="ttdeci">#define guac_mem_ckd_add_or_die(...)</div><div class="ttdoc">Adds together each of the given values, returning the result directly.</div><div class="ttdef"><b>Definition</b> mem.h:270</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a + b + c;</div>
</div><!-- fragment --><p>except that an overflow condition will result in the process immediately terminating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>The size_t values that should be added together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the addition. If the addition operation would overflow the limits of a size_t, execution of the current process is aborted, and this function does not return. </dd></dl>

</div>
</div>
<a id="ae47dabfecd807b320fa8ca35b836c3ed" name="ae47dabfecd807b320fa8ca35b836c3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47dabfecd807b320fa8ca35b836c3ed">&#9670;&#160;</a></span>guac_mem_ckd_mul</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_mul</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">result, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_mul(                                                    \</div>
<div class="line">        result,                                                               \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Multiplies together each of the given values, storing the result in a size_t variable via the provided pointer. </p>
<p>If the result of the multiplication overflows the limits of a size_t, non-zero is returned to signal failure.</p>
<p>If the multiplication operation fails, the nature of any result stored in the provided pointer is undefined, as is whether a result is stored at all.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result;</div>
<div class="line"><span class="keywordtype">int</span> failed = <a class="code hl_define" href="#ae47dabfecd807b320fa8ca35b836c3ed">guac_mem_ckd_mul</a>(&amp;some_result, a, b, c);</div>
<div class="ttc" id="amem_8h_html_ae47dabfecd807b320fa8ca35b836c3ed"><div class="ttname"><a href="#ae47dabfecd807b320fa8ca35b836c3ed">guac_mem_ckd_mul</a></div><div class="ttdeci">#define guac_mem_ckd_mul(result,...)</div><div class="ttdoc">Multiplies together each of the given values, storing the result in a size_t variable via the provide...</div><div class="ttdef"><b>Definition</b> mem.h:125</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a * b * c;</div>
</div><!-- fragment --><p>except that it is possible for interested callers to handle overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A pointer to the size_t variable that should receive the result of multiplying the given values.</td></tr>
    <tr><td class="paramname">...</td><td>The size_t values that should be multiplied together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the multiplication was successful and did not overflow the limits of a size_t, non-zero otherwise. </dd></dl>

</div>
</div>
<a id="a2ea1730f0b59705fcd6e8ce58fa6e244" name="a2ea1730f0b59705fcd6e8ce58fa6e244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea1730f0b59705fcd6e8ce58fa6e244">&#9670;&#160;</a></span>guac_mem_ckd_mul_or_die</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_mul_or_die</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_mul_or_die(                                             \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Multiplies together each of the given values, returning the result directly. </p>
<p>If the result of the multiplication overflows the limits of a size_t, execution of the current process is aborted entirely, and this function does not return.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = <a class="code hl_define" href="#a2ea1730f0b59705fcd6e8ce58fa6e244">guac_mem_ckd_mul_or_die</a>(a, b, c);</div>
<div class="ttc" id="amem_8h_html_a2ea1730f0b59705fcd6e8ce58fa6e244"><div class="ttname"><a href="#a2ea1730f0b59705fcd6e8ce58fa6e244">guac_mem_ckd_mul_or_die</a></div><div class="ttdeci">#define guac_mem_ckd_mul_or_die(...)</div><div class="ttdoc">Multiplies together each of the given values, returning the result directly.</div><div class="ttdef"><b>Definition</b> mem.h:238</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a * b * c;</div>
</div><!-- fragment --><p>except that an overflow condition will result in the process immediately terminating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>The size_t values that should be multiplied together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication. If the multiplication operation would overflow the limits of a size_t, execution of the current process is aborted, and this function does not return. </dd></dl>

</div>
</div>
<a id="aa7f393eafbe5d770cddac0821b69a74c" name="aa7f393eafbe5d770cddac0821b69a74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f393eafbe5d770cddac0821b69a74c">&#9670;&#160;</a></span>guac_mem_ckd_sub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_sub</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">result, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_sub(                                                    \</div>
<div class="line">        result,                                                               \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Subtracts each of the given values from each other, storing the result in a size_t variable via the provided pointer. </p>
<p>If the result of the subtraction overflows the limits of a size_t (goes below zero), non-zero is returned to signal failure.</p>
<p>If the subtraction operation fails, the nature of any result stored in the provided pointer is undefined, as is whether a result is stored at all.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result;</div>
<div class="line"><span class="keywordtype">int</span> failed = <a class="code hl_define" href="#aa7f393eafbe5d770cddac0821b69a74c">guac_mem_ckd_sub</a>(&amp;some_result, a, b, c);</div>
<div class="ttc" id="amem_8h_html_aa7f393eafbe5d770cddac0821b69a74c"><div class="ttname"><a href="#aa7f393eafbe5d770cddac0821b69a74c">guac_mem_ckd_sub</a></div><div class="ttdeci">#define guac_mem_ckd_sub(result,...)</div><div class="ttdoc">Subtracts each of the given values from each other, storing the result in a size_t variable via the p...</div><div class="ttdef"><b>Definition</b> mem.h:204</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a - b - c;</div>
</div><!-- fragment --><p>except that it is possible for interested callers to handle overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A pointer to the size_t variable that should receive the result of subtracting the given values from each other.</td></tr>
    <tr><td class="paramname">...</td><td>The size_t values that should be subtracted from each other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the subtraction was successful and did not overflow the limits of a size_t (did not go below zero), non-zero otherwise. </dd></dl>

</div>
</div>
<a id="acfbd36b5c5601983cf87a67a4e0b7fc9" name="acfbd36b5c5601983cf87a67a4e0b7fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd36b5c5601983cf87a67a4e0b7fc9">&#9670;&#160;</a></span>guac_mem_ckd_sub_or_die</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_ckd_sub_or_die</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_ckd_sub_or_die(                                             \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Subtracts each of the given values from each other, returning the result directly. </p>
<p>If the result of the subtraction overflows the limits of a size_t (goes below zero), execution of the current process is aborted entirely, and this function does not return.</p>
<p>For example, the following: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = <a class="code hl_define" href="#acfbd36b5c5601983cf87a67a4e0b7fc9">guac_mem_ckd_sub_or_die</a>(a, b, c);</div>
<div class="ttc" id="amem_8h_html_acfbd36b5c5601983cf87a67a4e0b7fc9"><div class="ttname"><a href="#acfbd36b5c5601983cf87a67a4e0b7fc9">guac_mem_ckd_sub_or_die</a></div><div class="ttdeci">#define guac_mem_ckd_sub_or_die(...)</div><div class="ttdoc">Subtracts each of the given values from each other, returning the result directly.</div><div class="ttdef"><b>Definition</b> mem.h:303</div></div>
</div><!-- fragment --><p>is equivalent in principle to: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> some_result = a - b - c;</div>
</div><!-- fragment --><p>except that an overflow condition will result in the process immediately terminating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>The size_t values that should be subtracted from each other.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction. If the subtraction operation would overflow the limits of a size_t (go below zero), execution of the current process is aborted, and this function does not return. </dd></dl>

</div>
</div>
<a id="aca926fbc99ae497f093235f787b5b328" name="aca926fbc99ae497f093235f787b5b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca926fbc99ae497f093235f787b5b328">&#9670;&#160;</a></span>guac_mem_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_free</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">mem</span></td><td>)</td>
          <td>&#160;&#160;&#160;(PRIV_guac_mem_free(mem), (mem) = NULL, (void) 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory block at the given pointer, which MUST have been allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants. </p>
<p>The pointer is automatically assigned a value of NULL after memory is freed. If the provided pointer is already NULL, this macro has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the memory to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af8ba72e97f84fbd7600be04cc6bf39" name="a3af8ba72e97f84fbd7600be04cc6bf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af8ba72e97f84fbd7600be04cc6bf39">&#9670;&#160;</a></span>guac_mem_free_const</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_free_const</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">mem</span></td><td>)</td>
          <td>&#160;&#160;&#160;PRIV_guac_mem_free((void*) (mem))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory block at the given const pointer, which MUST have been allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants. </p>
<p>As the pointer is presumed constant, it is not automatically assigned a value of NULL after memory is freed. If the provided pointer is NULL, this macro has no effect.</p>
<p>The <a class="el" href="#aca926fbc99ae497f093235f787b5b328" title="Frees the memory block at the given pointer, which MUST have been allocated with guac_mem_alloc(),...">guac_mem_free()</a> macro should be used in favor of this macro. This macro should only be used in cases where a constant pointer is absolutely necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>A pointer to the memory to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57937a45796bf46eb8d3945f8eecc201" name="a57937a45796bf46eb8d3945f8eecc201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57937a45796bf46eb8d3945f8eecc201">&#9670;&#160;</a></span>guac_mem_realloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_realloc</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">mem, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_realloc(                                                    \</div>
<div class="line">        mem,                                                                  \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Reallocates a contiguous block of memory that was previously allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants, returning a pointer to the first byte of that reallocated block of memory. </p>
<p>If multiple sizes are provided, these sizes are multiplied together to produce the final size of the new block. If memory of the specified size cannot be allocated, or if multiplying the sizes would result in integer overflow, guac_error is set appropriately, the original block of memory is left untouched, and NULL is returned.</p>
<p>This macro is analogous to the standard realloc(), but accepts a list of size factors instead of a requiring exactly one integer size.</p>
<p>The returned pointer may be the same as the original pointer, but this is not guaranteed. If the returned pointer is different, the original pointer is automatically freed.</p>
<p>The pointer returned by <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a> SHOULD be freed with a subsequent call to <a class="el" href="#aca926fbc99ae497f093235f787b5b328" title="Frees the memory block at the given pointer, which MUST have been allocated with guac_mem_alloc(),...">guac_mem_free()</a>, but MAY instead be freed with a subsequent call to free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A series of one or more size_t values that should be multiplied together to produce the desired block size. At least one value MUST be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first byte of the reallocated block of memory, or NULL if such a block could not be allocated. If a block of memory could not be allocated, guac_error is set appropriately and the original block of memory is left untouched. </dd></dl>

</div>
</div>
<a id="a1bf838d4e8ca2397170fa71a675192ba" name="a1bf838d4e8ca2397170fa71a675192ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf838d4e8ca2397170fa71a675192ba">&#9670;&#160;</a></span>guac_mem_realloc_or_die</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_realloc_or_die</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">mem, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_realloc_or_die(                                             \</div>
<div class="line">        mem,                                                                  \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Reallocates a contiguous block of memory that was previously allocated with <a class="el" href="#a4bb1a3a4a576b07b46b7326435e19cc5" title="Allocates a contiguous block of memory with the specified size, returning a pointer to the first byte...">guac_mem_alloc()</a>, <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a>, <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a>, or one of their *_or_die() variants, returning a pointer to the first byte of that reallocated block of memory. </p>
<p>If multiple sizes are provided, these sizes are multiplied together to produce the final size of the new block. If memory of the specified size cannot be allocated, execution of the current process is aborted entirely, and this function does not return.</p>
<p>This macro is analogous to the standard realloc(), but accepts a list of size factors instead of a requiring exactly one integer size and does not return in the event a block cannot be allocated.</p>
<p>The returned pointer may be the same as the original pointer, but this is not guaranteed. If the returned pointer is different, the original pointer is automatically freed.</p>
<p>The pointer returned by <a class="el" href="#a57937a45796bf46eb8d3945f8eecc201" title="Reallocates a contiguous block of memory that was previously allocated with guac_mem_alloc(),...">guac_mem_realloc()</a> SHOULD be freed with a subsequent call to <a class="el" href="#aca926fbc99ae497f093235f787b5b328" title="Frees the memory block at the given pointer, which MUST have been allocated with guac_mem_alloc(),...">guac_mem_free()</a>, but MAY instead be freed with a subsequent call to free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A series of one or more size_t values that should be multiplied together to produce the desired block size. At least one value MUST be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first byte of the reallocated block of memory. If a block of memory could not be allocated, execution of the current process is aborted, and this function does not return. </dd></dl>

</div>
</div>
<a id="a03391fbf6e9bababa2acc8d2094f42d2" name="a03391fbf6e9bababa2acc8d2094f42d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03391fbf6e9bababa2acc8d2094f42d2">&#9670;&#160;</a></span>guac_mem_zalloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define guac_mem_zalloc</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    PRIV_guac_mem_zalloc(                                                     \</div>
<div class="line">        <span class="keyword">sizeof</span>((<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }) / <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>),      \</div>
<div class="line">        (<span class="keyword">const</span> <span class="keywordtype">size_t</span>[]) { __VA_ARGS__ }                                      \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero, returning a pointer to the first byte of that block of memory. </p>
<p>If multiple sizes are provided, these sizes are multiplied together to produce the final size of the new block. If memory of the specified size cannot be allocated, or if multiplying the sizes would result in integer overflow, guac_error is set appropriately and NULL is returned.</p>
<p>This macro is analogous to the standard calloc(), but accepts a list of size factors instead of a requiring exactly two integer sizes.</p>
<p>The pointer returned by <a class="el" href="#a03391fbf6e9bababa2acc8d2094f42d2" title="Allocates a contiguous block of memory with the specified size and with all bytes initialized to zero...">guac_mem_zalloc()</a> SHOULD be freed with a subsequent call to <a class="el" href="#aca926fbc99ae497f093235f787b5b328" title="Frees the memory block at the given pointer, which MUST have been allocated with guac_mem_alloc(),...">guac_mem_free()</a>, but MAY instead be freed with a subsequent call to free().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A series of one or more size_t values that should be multiplied together to produce the desired block size. At least one value MUST be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first byte of the allocated block of memory, or NULL if such a block could not be allocated. If a block of memory could not be allocated, guac_error is set appropriately. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
