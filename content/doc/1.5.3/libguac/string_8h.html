<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libguac: guacamole/string.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libguac<span id="projectnumber">&#160;1.5.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6bb9fad85c98b48a11165f494b9f53ce.html">guacamole</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">string.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides convenience functions for manipulating strings.  
<a href="#details">More...</a></p>

<p><a href="string_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:add551909cdd14d762106832a800a5e16"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#add551909cdd14d762106832a800a5e16">guac_strlcpy</a> (char *restrict dest, const char *restrict src, size_t n)</td></tr>
<tr class="memdesc:add551909cdd14d762106832a800a5e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from the given source string to the given destination buffer.  <br /></td></tr>
<tr class="separator:add551909cdd14d762106832a800a5e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dccfb28be71414fb2a4b1b641799f57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a0dccfb28be71414fb2a4b1b641799f57">guac_strlcat</a> (char *restrict dest, const char *restrict src, size_t n)</td></tr>
<tr class="memdesc:a0dccfb28be71414fb2a4b1b641799f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given source string after the end of the given destination string, writing at most the given number of bytes.  <br /></td></tr>
<tr class="separator:a0dccfb28be71414fb2a4b1b641799f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29a3e046b785d93e1db17f33f3e996e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#aa29a3e046b785d93e1db17f33f3e996e">guac_strnstr</a> (const char *haystack, const char *needle, size_t len)</td></tr>
<tr class="memdesc:aa29a3e046b785d93e1db17f33f3e996e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the null-terminated string needle in the possibly null- terminated haystack, looking at no more than len bytes.  <br /></td></tr>
<tr class="separator:aa29a3e046b785d93e1db17f33f3e996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac446136fc070b071862d422b777eafc3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#ac446136fc070b071862d422b777eafc3">guac_strdup</a> (const char *str)</td></tr>
<tr class="memdesc:ac446136fc070b071862d422b777eafc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper for strdup() which behaves identically to standard strdup(), except that NULL will be returned if the provided string is NULL.  <br /></td></tr>
<tr class="separator:ac446136fc070b071862d422b777eafc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186ea73f38cfaf14f8a5b13ad7e9724f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string_8h.html#a186ea73f38cfaf14f8a5b13ad7e9724f">guac_strljoin</a> (char *restrict dest, const char *restrict const *elements, int nmemb, const char *restrict delim, size_t n)</td></tr>
<tr class="memdesc:a186ea73f38cfaf14f8a5b13ad7e9724f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each of the given strings, separated by the given delimiter, storing the result within a destination buffer.  <br /></td></tr>
<tr class="separator:a186ea73f38cfaf14f8a5b13ad7e9724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides convenience functions for manipulating strings. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac446136fc070b071862d422b777eafc3" name="ac446136fc070b071862d422b777eafc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac446136fc070b071862d422b777eafc3">&#9670;&#160;</a></span>guac_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * guac_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple wrapper for strdup() which behaves identically to standard strdup(), except that NULL will be returned if the provided string is NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to duplicate as a newly-allocated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-allocated string containing identically the same content as the given string, or NULL if the given string was NULL. </dd></dl>

</div>
</div>
<a id="a0dccfb28be71414fb2a4b1b641799f57" name="a0dccfb28be71414fb2a4b1b641799f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dccfb28be71414fb2a4b1b641799f57">&#9670;&#160;</a></span>guac_strlcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t guac_strlcat </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the given source string after the end of the given destination string, writing at most the given number of bytes. </p>
<p>Both the source and destination strings MUST be null-terminated. The resulting buffer will always be null-terminated, even if doing so means that the intended string is truncated, unless the destination buffer has no space available at all. As this function always returns the length of the string it tried to create (the length of destination and source strings added together), whether truncation has occurred can be detected by comparing the return value against the size of the destination buffer. If the value returned is greater than or equal to the size of the destination buffer, then the string has been truncated.</p>
<p>The source and destination buffers MAY NOT overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The buffer which should be appended with the contents of the source string. This buffer MUST already be null-terminated and will always be null-terminated unless zero bytes are available within the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>As a safeguard against incorrectly-written code, in the event that the destination buffer is not null-terminated, this function will still stop before overrunning the buffer, instead behaving as if the length of the string in the buffer is exactly the size of the buffer. The destination buffer will remain untouched (and unterminated) in this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source string to append to the the destination buffer. This string MUST be null-terminated.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes available within the destination buffer. If this value is not greater than zero, no bytes will be written to the destination buffer, and the destination buffer may not be null-terminated. In all other cases, the destination buffer will always be null-terminated, even if doing so means that the copied data from the source string will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string this function tried to create (the lengths of the source and destination strings added together) in bytes, excluding the null terminator. </dd></dl>

</div>
</div>
<a id="add551909cdd14d762106832a800a5e16" name="add551909cdd14d762106832a800a5e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add551909cdd14d762106832a800a5e16">&#9670;&#160;</a></span>guac_strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t guac_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a limited number of bytes from the given source string to the given destination buffer. </p>
<p>The resulting buffer will always be null-terminated, even if doing so means that the intended string is truncated, unless the destination buffer has no space available at all. As this function always returns the length of the string it tried to create (the length of the source string), whether truncation has occurred can be detected by comparing the return value against the size of the destination buffer. If the value returned is greater than or equal to the size of the destination buffer, then the string has been truncated.</p>
<p>The source and destination buffers MAY NOT overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The buffer which should receive the contents of the source string. This buffer will always be null terminated unless zero bytes are available within the buffer.</td></tr>
    <tr><td class="paramname">src</td><td>The source string to copy into the destination buffer. This string MUST be null terminated.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes available within the destination buffer. If this value is zero, no bytes will be written to the destination buffer, and the destination buffer may not be null terminated. In all other cases, the destination buffer will always be null terminated, even if doing so means that the copied data from the source string will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the copied string (the source string) in bytes, excluding the null terminator. </dd></dl>

</div>
</div>
<a id="a186ea73f38cfaf14f8a5b13ad7e9724f" name="a186ea73f38cfaf14f8a5b13ad7e9724f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186ea73f38cfaf14f8a5b13ad7e9724f">&#9670;&#160;</a></span>guac_strljoin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t guac_strljoin </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict const *&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates each of the given strings, separated by the given delimiter, storing the result within a destination buffer. </p>
<p>The number of bytes written will be no more than the given number of bytes, and the destination buffer is guaranteed to be null-terminated, even if doing so means that one or more of the intended strings are truncated or omitted from the end of the result, unless the destination buffer has no space available at all. As this function always returns the length of the string it tried to create (the length of all source strings and all delimiters added together), whether truncation has occurred can be detected by comparing the return value against the size of the destination buffer. If the value returned is greater than or equal to the size of the destination buffer, then the string has been truncated.</p>
<p>The source strings, delimiter string, and destination buffer MAY NOT overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The buffer which should receive the result of joining the given strings. This buffer will always be null terminated unless zero bytes are available within the buffer.</td></tr>
    <tr><td class="paramname">elements</td><td>The elements to concatenate together, separated by the given delimiter. Each element MUST be null-terminated.</td></tr>
    <tr><td class="paramname">nmemb</td><td>The number of elements within the elements array.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter to include between each pair of elements.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes available within the destination buffer. If this value is not greater than zero, no bytes will be written to the destination buffer, and the destination buffer may not be null terminated. In all other cases, the destination buffer will always be null terminated, even if doing so means that the result will be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string this function tried to create (the length of all source strings and all delimiters added together) in bytes, excluding the null terminator. </dd></dl>

</div>
</div>
<a id="aa29a3e046b785d93e1db17f33f3e996e" name="aa29a3e046b785d93e1db17f33f3e996e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29a3e046b785d93e1db17f33f3e996e">&#9670;&#160;</a></span>guac_strnstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * guac_strnstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the null-terminated string needle in the possibly null- terminated haystack, looking at no more than len bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The string to search. It may or may not be null-terminated. Only the first len bytes are searched.</td></tr>
    <tr><td class="paramname">needle</td><td>The string to look for. It must be null-terminated.</td></tr>
    <tr><td class="paramname">len</td><td>The maximum number of bytes to examine in haystack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first instance of needle within haystack, or NULL if needle does not exist in haystack. If needle is the empty string, haystack is returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
