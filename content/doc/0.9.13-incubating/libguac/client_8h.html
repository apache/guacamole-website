<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libguac: guacamole/client.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libguac
   &#160;<span id="projectnumber">0.9.13-incubating</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6bb9fad85c98b48a11165f494b9f53ce.html">guacamole</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">client.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions and structure contents for the Guacamole proxy client.  
<a href="#details">More...</a></p>

<p><a href="client_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structguac__client.html">guac_client</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guacamole proxy client.  <a href="structguac__client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33bad42d21ccb561aa71c4f04ae9b22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a33bad42d21ccb561aa71c4f04ae9b22a">guac_client_alloc</a> ()</td></tr>
<tr class="memdesc:a33bad42d21ccb561aa71c4f04ae9b22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new, barebones <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a>.  <a href="#a33bad42d21ccb561aa71c4f04ae9b22a">More...</a><br /></td></tr>
<tr class="separator:a33bad42d21ccb561aa71c4f04ae9b22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cdc454a23fdcbb70d56f923f6b6427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a76cdc454a23fdcbb70d56f923f6b6427">guac_client_free</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a76cdc454a23fdcbb70d56f923f6b6427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all resources associated with the given client.  <a href="#a76cdc454a23fdcbb70d56f923f6b6427">More...</a><br /></td></tr>
<tr class="separator:a76cdc454a23fdcbb70d56f923f6b6427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53666bbe29346497cabb04fc9628208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#ad53666bbe29346497cabb04fc9628208">guac_client_log</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="client-types_8h.html#adfeeb4ff06541220c91ce3401d840727">guac_client_log_level</a> level, const char *format,...)</td></tr>
<tr class="memdesc:ad53666bbe29346497cabb04fc9628208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message in the log used by the given client.  <a href="#ad53666bbe29346497cabb04fc9628208">More...</a><br /></td></tr>
<tr class="separator:ad53666bbe29346497cabb04fc9628208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0fa9cfc4c02236085e3852972f494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a37a0fa9cfc4c02236085e3852972f494">vguac_client_log</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="client-types_8h.html#adfeeb4ff06541220c91ce3401d840727">guac_client_log_level</a> level, const char *format, va_list ap)</td></tr>
<tr class="memdesc:a37a0fa9cfc4c02236085e3852972f494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message in the log used by the given client.  <a href="#a37a0fa9cfc4c02236085e3852972f494">More...</a><br /></td></tr>
<tr class="separator:a37a0fa9cfc4c02236085e3852972f494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022d4b5587c84f2963b176ab7999aa1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a022d4b5587c84f2963b176ab7999aa1b">guac_client_stop</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a022d4b5587c84f2963b176ab7999aa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the given client to stop gracefully.  <a href="#a022d4b5587c84f2963b176ab7999aa1b">More...</a><br /></td></tr>
<tr class="separator:a022d4b5587c84f2963b176ab7999aa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a29f7820deaff00a10ec79aa81aed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a62a29f7820deaff00a10ec79aa81aed4">guac_client_abort</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="protocol-types_8h.html#af946f7f843fa5935dbeeb08f85dec9e2">guac_protocol_status</a> status, const char *format,...)</td></tr>
<tr class="memdesc:a62a29f7820deaff00a10ec79aa81aed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the given client to stop gracefully, while also signalling via the Guacamole protocol that an error has occurred.  <a href="#a62a29f7820deaff00a10ec79aa81aed4">More...</a><br /></td></tr>
<tr class="separator:a62a29f7820deaff00a10ec79aa81aed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0eccd7d0ed3dbf3e7941ce297e0224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a4c0eccd7d0ed3dbf3e7941ce297e0224">vguac_client_abort</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="protocol-types_8h.html#af946f7f843fa5935dbeeb08f85dec9e2">guac_protocol_status</a> status, const char *format, va_list ap)</td></tr>
<tr class="memdesc:a4c0eccd7d0ed3dbf3e7941ce297e0224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the given client to stop gracefully, while also signalling via the Guacamole protocol that an error has occurred.  <a href="#a4c0eccd7d0ed3dbf3e7941ce297e0224">More...</a><br /></td></tr>
<tr class="separator:a4c0eccd7d0ed3dbf3e7941ce297e0224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af661d3fedd9683631bdc7d1e3205e379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#af661d3fedd9683631bdc7d1e3205e379">guac_client_alloc_buffer</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:af661d3fedd9683631bdc7d1e3205e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new buffer (invisible layer).  <a href="#af661d3fedd9683631bdc7d1e3205e379">More...</a><br /></td></tr>
<tr class="separator:af661d3fedd9683631bdc7d1e3205e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2085758db585bb9d09d3860ec0fc9587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a2085758db585bb9d09d3860ec0fc9587">guac_client_alloc_layer</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a2085758db585bb9d09d3860ec0fc9587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new layer.  <a href="#a2085758db585bb9d09d3860ec0fc9587">More...</a><br /></td></tr>
<tr class="separator:a2085758db585bb9d09d3860ec0fc9587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03a32b3113d9a95700cac54f1cbd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#afc03a32b3113d9a95700cac54f1cbd4b">guac_client_free_buffer</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__layer.html">guac_layer</a> *layer)</td></tr>
<tr class="memdesc:afc03a32b3113d9a95700cac54f1cbd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given buffer to the pool of available buffers, such that it can be reused by any subsequent call to guac_client_allow_buffer().  <a href="#afc03a32b3113d9a95700cac54f1cbd4b">More...</a><br /></td></tr>
<tr class="separator:afc03a32b3113d9a95700cac54f1cbd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b374211012d1897792335112dcb89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a4e5b374211012d1897792335112dcb89">guac_client_free_layer</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__layer.html">guac_layer</a> *layer)</td></tr>
<tr class="memdesc:a4e5b374211012d1897792335112dcb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given layer to the pool of available layers, such that it can be reused by any subsequent call to guac_client_allow_layer().  <a href="#a4e5b374211012d1897792335112dcb89">More...</a><br /></td></tr>
<tr class="separator:a4e5b374211012d1897792335112dcb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bea3499e21736b4ea0fb949d3bc8ab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structguac__stream.html">guac_stream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a1bea3499e21736b4ea0fb949d3bc8ab9">guac_client_alloc_stream</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a1bea3499e21736b4ea0fb949d3bc8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new stream.  <a href="#a1bea3499e21736b4ea0fb949d3bc8ab9">More...</a><br /></td></tr>
<tr class="separator:a1bea3499e21736b4ea0fb949d3bc8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0103a5aae8ba76badd2e68e827f6782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#af0103a5aae8ba76badd2e68e827f6782">guac_client_free_stream</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__stream.html">guac_stream</a> *stream)</td></tr>
<tr class="memdesc:af0103a5aae8ba76badd2e68e827f6782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given stream to the pool of available streams, such that it can be reused by any subsequent call to <a class="el" href="client_8h.html#a1bea3499e21736b4ea0fb949d3bc8ab9" title="Allocates a new stream. ">guac_client_alloc_stream()</a>.  <a href="#af0103a5aae8ba76badd2e68e827f6782">More...</a><br /></td></tr>
<tr class="separator:af0103a5aae8ba76badd2e68e827f6782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d105dfd1453ec46b423e6b25fa371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#af66d105dfd1453ec46b423e6b25fa371">guac_client_add_user</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__user.html">guac_user</a> *user, int argc, char **argv)</td></tr>
<tr class="memdesc:af66d105dfd1453ec46b423e6b25fa371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given user to the internal list of connected users.  <a href="#af66d105dfd1453ec46b423e6b25fa371">More...</a><br /></td></tr>
<tr class="separator:af66d105dfd1453ec46b423e6b25fa371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02832d5be5330dc3de524b497b7c6dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a02832d5be5330dc3de524b497b7c6dfa">guac_client_remove_user</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__user.html">guac_user</a> *user)</td></tr>
<tr class="memdesc:a02832d5be5330dc3de524b497b7c6dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given user, removing the user from the internally-tracked list of connected users, and calling any appropriate leave handler.  <a href="#a02832d5be5330dc3de524b497b7c6dfa">More...</a><br /></td></tr>
<tr class="separator:a02832d5be5330dc3de524b497b7c6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af652f3db0f89d488cef6d90f612a2077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#af652f3db0f89d488cef6d90f612a2077">guac_client_foreach_user</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *callback, void *data)</td></tr>
<tr class="memdesc:af652f3db0f89d488cef6d90f612a2077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function on all currently-connected users of the given client.  <a href="#af652f3db0f89d488cef6d90f612a2077">More...</a><br /></td></tr>
<tr class="separator:af652f3db0f89d488cef6d90f612a2077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f4ed85d98b16376e2cdc031ff1b44a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#af3f4ed85d98b16376e2cdc031ff1b44a">guac_client_for_owner</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *callback, void *data)</td></tr>
<tr class="memdesc:af3f4ed85d98b16376e2cdc031ff1b44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the currently-connected user that is marked as the owner.  <a href="#af3f4ed85d98b16376e2cdc031ff1b44a">More...</a><br /></td></tr>
<tr class="separator:af3f4ed85d98b16376e2cdc031ff1b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbba296d1ec3e78dc4b79884f590a03"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a7fbba296d1ec3e78dc4b79884f590a03">guac_client_for_user</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__user.html">guac_user</a> *user, <a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *callback, void *data)</td></tr>
<tr class="memdesc:a7fbba296d1ec3e78dc4b79884f590a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the given function with the given user ONLY if they are currently connected.  <a href="#a7fbba296d1ec3e78dc4b79884f590a03">More...</a><br /></td></tr>
<tr class="separator:a7fbba296d1ec3e78dc4b79884f590a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686fc65f5b1afcc3f3b53e36cd1a2ebc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a686fc65f5b1afcc3f3b53e36cd1a2ebc">guac_client_end_frame</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a686fc65f5b1afcc3f3b53e36cd1a2ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the end of the current frame by sending a "sync" instruction to all connected users.  <a href="#a686fc65f5b1afcc3f3b53e36cd1a2ebc">More...</a><br /></td></tr>
<tr class="separator:a686fc65f5b1afcc3f3b53e36cd1a2ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b90d686c56cf753c36718ec085f35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#afa2b90d686c56cf753c36718ec085f35">guac_client_load_plugin</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, const char *protocol)</td></tr>
<tr class="memdesc:afa2b90d686c56cf753c36718ec085f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the given <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> using the initialization routine provided by the plugin corresponding to the named protocol.  <a href="#afa2b90d686c56cf753c36718ec085f35">More...</a><br /></td></tr>
<tr class="separator:afa2b90d686c56cf753c36718ec085f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b94b3145fcebf2d7b1999df11d0b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#aa2b94b3145fcebf2d7b1999df11d0b2c">guac_client_get_processing_lag</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:aa2b94b3145fcebf2d7b1999df11d0b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the approximate processing lag experienced by the pool of users.  <a href="#aa2b94b3145fcebf2d7b1999df11d0b2c">More...</a><br /></td></tr>
<tr class="separator:aa2b94b3145fcebf2d7b1999df11d0b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317b9d79afd0b0b473d7d359e0c33750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a317b9d79afd0b0b473d7d359e0c33750">guac_client_stream_png</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__socket.html">guac_socket</a> *socket, <a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a> mode, const <a class="el" href="structguac__layer.html">guac_layer</a> *layer, int x, int y, cairo_surface_t *surface)</td></tr>
<tr class="memdesc:a317b9d79afd0b0b473d7d359e0c33750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams the image data of the given surface over an image stream ("img" instruction) as PNG-encoded data.  <a href="#a317b9d79afd0b0b473d7d359e0c33750">More...</a><br /></td></tr>
<tr class="separator:a317b9d79afd0b0b473d7d359e0c33750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ede155ad7777bc8d2e82aa6e779bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#aa51ede155ad7777bc8d2e82aa6e779bf">guac_client_stream_jpeg</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__socket.html">guac_socket</a> *socket, <a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a> mode, const <a class="el" href="structguac__layer.html">guac_layer</a> *layer, int x, int y, cairo_surface_t *surface, int quality)</td></tr>
<tr class="memdesc:aa51ede155ad7777bc8d2e82aa6e779bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams the image data of the given surface over an image stream ("img" instruction) as JPEG-encoded data at the given quality.  <a href="#aa51ede155ad7777bc8d2e82aa6e779bf">More...</a><br /></td></tr>
<tr class="separator:aa51ede155ad7777bc8d2e82aa6e779bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55adbd5ee8f27c4df4394dbb5bf9416e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a55adbd5ee8f27c4df4394dbb5bf9416e">guac_client_stream_webp</a> (<a class="el" href="structguac__client.html">guac_client</a> *client, <a class="el" href="structguac__socket.html">guac_socket</a> *socket, <a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a> mode, const <a class="el" href="structguac__layer.html">guac_layer</a> *layer, int x, int y, cairo_surface_t *surface, int quality, int lossless)</td></tr>
<tr class="memdesc:a55adbd5ee8f27c4df4394dbb5bf9416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams the image data of the given surface over an image stream ("img" instruction) as WebP-encoded data at the given quality.  <a href="#a55adbd5ee8f27c4df4394dbb5bf9416e">More...</a><br /></td></tr>
<tr class="separator:a55adbd5ee8f27c4df4394dbb5bf9416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cc74558e8f64807ea2847fbacd20e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a79cc74558e8f64807ea2847fbacd20e3">guac_client_supports_webp</a> (<a class="el" href="structguac__client.html">guac_client</a> *client)</td></tr>
<tr class="memdesc:a79cc74558e8f64807ea2847fbacd20e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all users of the given client support WebP.  <a href="#a79cc74558e8f64807ea2847fbacd20e3">More...</a><br /></td></tr>
<tr class="separator:a79cc74558e8f64807ea2847fbacd20e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a336a485c006394d5eea88bf6d8d422d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a336a485c006394d5eea88bf6d8d422d8"></a>
const <a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="client_8h.html#a336a485c006394d5eea88bf6d8d422d8">GUAC_DEFAULT_LAYER</a></td></tr>
<tr class="memdesc:a336a485c006394d5eea88bf6d8d422d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default Guacamole client layer, layer 0. <br /></td></tr>
<tr class="separator:a336a485c006394d5eea88bf6d8d422d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions and structure contents for the Guacamole proxy client. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a62a29f7820deaff00a10ec79aa81aed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol-types_8h.html#af946f7f843fa5935dbeeb08f85dec9e2">guac_protocol_status</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals the given client to stop gracefully, while also signalling via the Guacamole protocol that an error has occurred. </p>
<p>Note that this is a completely cooperative signal, and can be ignored by the client or the hosting daemon. The message given will be logged to the system logs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to signal to stop. </td></tr>
    <tr><td class="paramname">status</td><td>The status to send over the Guacamole protocol. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string to log. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments to use when filling the format string for printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af66d105dfd1453ec46b423e6b25fa371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int guac_client_add_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__user.html">guac_user</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given user to the internal list of connected users. </p>
<p>Future writes to the broadcast socket stored within <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> will also write to this user. The join handler of this <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to add the user to. </td></tr>
    <tr><td class="paramname">user</td><td>The user to add. </td></tr>
    <tr><td class="paramname">argc</td><td>The number of arguments to pass to the new user. </td></tr>
    <tr><td class="paramname">argv</td><td>An array of strings containing the argument values being passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the user was added successfully, non-zero if the user could not join the connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a33bad42d21ccb561aa71c4f04ae9b22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structguac__client.html">guac_client</a>* guac_client_alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new, barebones <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a>. </p>
<p>This new <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> has no handlers set, but is otherwise usable.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new client. </dd></dl>

</div>
</div>
<a class="anchor" id="af661d3fedd9683631bdc7d1e3205e379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structguac__layer.html">guac_layer</a>* guac_client_alloc_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new buffer (invisible layer). </p>
<p>An arbitrary index is automatically assigned if no existing buffer is available for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to allocate the buffer for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available buffer, or a newly allocated buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2085758db585bb9d09d3860ec0fc9587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structguac__layer.html">guac_layer</a>* guac_client_alloc_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new layer. </p>
<p>An arbitrary index is automatically assigned if no existing layer is available for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to allocate the layer buffer for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available layer, or a newly allocated layer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bea3499e21736b4ea0fb949d3bc8ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structguac__stream.html">guac_stream</a>* guac_client_alloc_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new stream. </p>
<p>An arbitrary index is automatically assigned if no previously-allocated stream is available for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to allocate the stream for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next available stream, or a newly allocated stream. </dd></dl>

</div>
</div>
<a class="anchor" id="a686fc65f5b1afcc3f3b53e36cd1a2ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int guac_client_end_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the end of the current frame by sending a "sync" instruction to all connected users. </p>
<p>This instruction will contain the current timestamp. The last_sent_timestamp member of <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> will be updated accordingly.</p>
<p>If an error occurs sending the instruction, a non-zero value is returned, and guac_error is set appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> which has finished a frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, non-zero on error. </dd></dl>

</div>
</div>
<a class="anchor" id="af3f4ed85d98b16376e2cdc031ff1b44a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* guac_client_for_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the currently-connected user that is marked as the owner. </p>
<p>The owner of a connection is the user that established the initial connection that created the connection (the first user to connect and join). The function will be given a reference to the <a class="el" href="structguac__user.html" title="Representation of a physical connection within a larger logical connection which may be shared...">guac_user</a> and the specified arbitrary data. If the owner has since left the connection, the function will instead be invoked with NULL as the <a class="el" href="structguac__user.html" title="Representation of a physical connection within a larger logical connection which may be shared...">guac_user</a>. The value returned by the callback will be returned by this function.</p>
<p>This function is reentrant, but the user list MUST NOT be manipulated within the same thread as a callback to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to retrieve the owner from.</td></tr>
    <tr><td class="paramname">callback</td><td>The callback to invoke on the user marked as the owner of the connection. NULL will be passed to this callback instead if there is no owner.</td></tr>
    <tr><td class="paramname">data</td><td>Arbitrary data to pass to the given callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned by the callback. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fbba296d1ec3e78dc4b79884f590a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* guac_client_for_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__user.html">guac_user</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function with the given user ONLY if they are currently connected. </p>
<p>The function will be given a reference to the <a class="el" href="structguac__user.html" title="Representation of a physical connection within a larger logical connection which may be shared...">guac_user</a> and the specified arbitrary data. If the provided user doesn't exist or has since left the connection, the function will instead be invoked with NULL as the <a class="el" href="structguac__user.html" title="Representation of a physical connection within a larger logical connection which may be shared...">guac_user</a>. The value returned by the callback will be returned by this function.</p>
<p>This function is reentrant, but the user list MUST NOT be manipulated within the same thread as a callback to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client that the given user is expected to be associated with.</td></tr>
    <tr><td class="paramname">user</td><td>The user to provide to the given callback if valid. The pointer need not even point to properly allocated memory; the user will only be passed to the callback function if they are valid, and the provided user pointer will not be dereferenced during this process.</td></tr>
    <tr><td class="paramname">callback</td><td>The callback to invoke on the given user if they are valid. NULL will be passed to this callback instead if the user is not valid.</td></tr>
    <tr><td class="paramname">data</td><td>Arbitrary data to pass to the given callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value returned by the callback. </dd></dl>

</div>
</div>
<a class="anchor" id="af652f3db0f89d488cef6d90f612a2077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_foreach_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="user-fntypes_8h.html#a99c5146e0ab1df9ba2b2574fb26fbddf">guac_user_callback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls the given function on all currently-connected users of the given client. </p>
<p>The function will be given a reference to a <a class="el" href="structguac__user.html" title="Representation of a physical connection within a larger logical connection which may be shared...">guac_user</a> and the specified arbitrary data. The value returned by the callback will be ignored.</p>
<p>This function is reentrant, but the user list MUST NOT be manipulated within the same thread as a callback to this function. Though the callback MAY invoke <a class="el" href="client_8h.html#af652f3db0f89d488cef6d90f612a2077" title="Calls the given function on all currently-connected users of the given client. ">guac_client_foreach_user()</a>, doing so should not be necessary, and may indicate poor design choices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client whose users should be iterated.</td></tr>
    <tr><td class="paramname">callback</td><td>The function to call for each user.</td></tr>
    <tr><td class="paramname">data</td><td>Arbitrary data to pass to the callback each time it is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76cdc454a23fdcbb70d56f923f6b6427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all resources associated with the given client. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to free all reasources of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc03a32b3113d9a95700cac54f1cbd4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_free_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given buffer to the pool of available buffers, such that it can be reused by any subsequent call to guac_client_allow_buffer(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to return the buffer to. </td></tr>
    <tr><td class="paramname">layer</td><td>The buffer to return to the pool of available buffers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e5b374211012d1897792335112dcb89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_free_layer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given layer to the pool of available layers, such that it can be reused by any subsequent call to guac_client_allow_layer(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to return the layer to. </td></tr>
    <tr><td class="paramname">layer</td><td>The buffer to return to the pool of available layer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0103a5aae8ba76badd2e68e827f6782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_free_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__stream.html">guac_stream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given stream to the pool of available streams, such that it can be reused by any subsequent call to <a class="el" href="client_8h.html#a1bea3499e21736b4ea0fb949d3bc8ab9" title="Allocates a new stream. ">guac_client_alloc_stream()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The client to return the stream to.</td></tr>
    <tr><td class="paramname">stream</td><td>The stream to return to the pool of available stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2b94b3145fcebf2d7b1999df11d0b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int guac_client_get_processing_lag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the approximate processing lag experienced by the pool of users. </p>
<p>The processing lag is the difference in time between server and client due purely to data processing and excluding network delays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> to calculate the processing lag of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximate processing lag of the pool of users associated with the given <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a>, in milliseconds. </dd></dl>

</div>
</div>
<a class="anchor" id="afa2b90d686c56cf753c36718ec085f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int guac_client_load_plugin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the given <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> using the initialization routine provided by the plugin corresponding to the named protocol. </p>
<p>This will automatically invoke guac_client_init within the plugin for the given protocol.</p>
<p>Note that the connection will likely not be established until the first user (the "owner") is added to the client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The <a class="el" href="structguac__client.html" title="Guacamole proxy client. ">guac_client</a> to initialize. </td></tr>
    <tr><td class="paramname">protocol</td><td>The name of the protocol to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if initialization was successful, non-zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad53666bbe29346497cabb04fc9628208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="client-types_8h.html#adfeeb4ff06541220c91ce3401d840727">guac_client_log_level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message in the log used by the given client. </p>
<p>The logger used will normally be defined by guacd (or whichever program loads the proxy client) by setting the logging handlers of the client when it is loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client logging this message. </td></tr>
    <tr><td class="paramname">level</td><td>The level at which to log this message. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string to log. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments to use when filling the format string for printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02832d5be5330dc3de524b497b7c6dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_remove_user </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__user.html">guac_user</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given user, removing the user from the internally-tracked list of connected users, and calling any appropriate leave handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to return the buffer to. </td></tr>
    <tr><td class="paramname">user</td><td>The user to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a022d4b5587c84f2963b176ab7999aa1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals the given client to stop gracefully. </p>
<p>This is a completely cooperative signal, and can be ignored by the client or the hosting daemon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to signal to stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa51ede155ad7777bc8d2e82aa6e779bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_stream_jpeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__socket.html">guac_socket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams the image data of the given surface over an image stream ("img" instruction) as JPEG-encoded data at the given quality. </p>
<p>The image stream will be automatically allocated and freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The Guacamole client for which the image stream should be allocated.</td></tr>
    <tr><td class="paramname">socket</td><td>The socket over which instructions associated with the image stream should be sent.</td></tr>
    <tr><td class="paramname">mode</td><td>The composite mode to use when rendering the image over the given layer.</td></tr>
    <tr><td class="paramname">layer</td><td>The destination layer.</td></tr>
    <tr><td class="paramname">x</td><td>The X coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">surface</td><td>A Cairo surface containing the image data to be streamed.</td></tr>
    <tr><td class="paramname">quality</td><td>The JPEG image quality, which must be an integer value between 0 and 100 inclusive. Larger values indicate improving quality at the expense of larger file size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a317b9d79afd0b0b473d7d359e0c33750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_stream_png </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__socket.html">guac_socket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams the image data of the given surface over an image stream ("img" instruction) as PNG-encoded data. </p>
<p>The image stream will be automatically allocated and freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The Guacamole client for which the image stream should be allocated.</td></tr>
    <tr><td class="paramname">socket</td><td>The socket over which instructions associated with the image stream should be sent.</td></tr>
    <tr><td class="paramname">mode</td><td>The composite mode to use when rendering the image over the given layer.</td></tr>
    <tr><td class="paramname">layer</td><td>The destination layer.</td></tr>
    <tr><td class="paramname">x</td><td>The X coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">surface</td><td>A Cairo surface containing the image data to be streamed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55adbd5ee8f27c4df4394dbb5bf9416e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void guac_client_stream_webp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structguac__socket.html">guac_socket</a> *&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol-types_8h.html#a93612063886db58071d02b5393abf186">guac_composite_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structguac__layer.html">guac_layer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lossless</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams the image data of the given surface over an image stream ("img" instruction) as WebP-encoded data at the given quality. </p>
<p>The image stream will be automatically allocated and freed. If the server does not support WebP, this function has no effect, so be sure to check the result of <a class="el" href="client_8h.html#a79cc74558e8f64807ea2847fbacd20e3" title="Returns whether all users of the given client support WebP. ">guac_client_supports_webp()</a> prior to calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The Guacamole client for whom the image stream should be allocated.</td></tr>
    <tr><td class="paramname">socket</td><td>The socket over which instructions associated with the image stream should be sent.</td></tr>
    <tr><td class="paramname">mode</td><td>The composite mode to use when rendering the image over the given layer.</td></tr>
    <tr><td class="paramname">layer</td><td>The destination layer.</td></tr>
    <tr><td class="paramname">x</td><td>The X coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the upper-left corner of the destination rectangle within the given layer.</td></tr>
    <tr><td class="paramname">surface</td><td>A Cairo surface containing the image data to be streamed.</td></tr>
    <tr><td class="paramname">quality</td><td>The WebP image quality, which must be an integer value between 0 and 100 inclusive. For lossy images, larger values indicate improving quality at the expense of larger file size. For lossless images, this dictates the quality of compression, with larger values producing smaller files at the expense of speed.</td></tr>
    <tr><td class="paramname">lossless</td><td>Zero to encode a lossy image, non-zero to encode losslessly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79cc74558e8f64807ea2847fbacd20e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int guac_client_supports_webp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether all users of the given client support WebP. </p>
<p>If any user does not support WebP, or the server cannot encode WebP images, zero is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The Guacamole client whose users should be checked for WebP support.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the all users of the given client claim to support WebP and the server has been built with WebP support, zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c0eccd7d0ed3dbf3e7941ce297e0224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vguac_client_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol-types_8h.html#af946f7f843fa5935dbeeb08f85dec9e2">guac_protocol_status</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals the given client to stop gracefully, while also signalling via the Guacamole protocol that an error has occurred. </p>
<p>Note that this is a completely cooperative signal, and can be ignored by the client or the hosting daemon. The message given will be logged to the system logs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client to signal to stop. </td></tr>
    <tr><td class="paramname">status</td><td>The status to send over the Guacamole protocol. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string to log. </td></tr>
    <tr><td class="paramname">ap</td><td>The va_list containing the arguments to be used when filling the format string for printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37a0fa9cfc4c02236085e3852972f494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vguac_client_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structguac__client.html">guac_client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="client-types_8h.html#adfeeb4ff06541220c91ce3401d840727">guac_client_log_level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message in the log used by the given client. </p>
<p>The logger used will normally be defined by guacd (or whichever program loads the proxy client) by setting the logging handlers of the client when it is loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>The proxy client logging this message. </td></tr>
    <tr><td class="paramname">level</td><td>The level at which to log this message. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string to log. </td></tr>
    <tr><td class="paramname">ap</td><td>The va_list containing the arguments to be used when filling the format string for printing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
